---
title: 面试问题笔记
description: 这里收录了有关面试可能会问到的问题的详细解释，具体的信息来源于渡一袁老师的大师课
date: 2025-11-24T18:25:22+08:00
image:
math: false
license:
hidden: false
comments: true
draft: true
---
### 阐述一下 JS 的事件循环

> 参考答案：
> 事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。
> 在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入队列末尾即可。
> 过去把消息队列简单的分为宏队列和微队列，这种说法目前已经无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。
> 根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须有点调度执行。

举个例子（微队列、交互队列、延迟队列）：

- 微队列：Promise
- 交互队列：按钮点击
- 延迟队列：setTimeout()

```javascript
// 延迟函数，用来阻塞主进程执行
function delay(duration) {
  const start = Date.now();
  while (Date.now() - start < duration) { }
}

// 微队列 Step1
Promise.resolve().then(() => {
  console.log(2);
})

// 延迟队列 Step2
setTimeout(() => {
  console.log(1)
})

// Step3
console.log(0);

delay(2000); // 阻塞主进程2秒
```

输出结果：

```
0
2
1
```

为什么是这个结果？

首先，浏览器需要执行主线程中的任务，执行到 `Step1` 会将这个 `Promise` 中的方法添加到**微队列**中等待执行，继续执行到 `Step2` 将延迟中的方法添加到**延迟队列**中等待执行，继续执行到 `Step3` 输出 0，因为**微队列的优先级比其他的队列优先级高**，所以会优先执行微队列中的任务，然后执行交互队列的任务，所以结果是 0 2 1。
### JS 中的计时器能做到精准计时吗？为什么？

> 参考答案：
> 不行，因为：
> 1. 计算机硬件没有原子钟，无法做到精确计时
> 2. 操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差
> 3. 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带 4 毫秒的最少时间这样在计时时间少于 4 毫秒时又带来了偏差
> 4. 